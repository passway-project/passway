# Passway Server Style Guide

This document outlines the coding style, conventions, and best practices for developing the Passway server, primarily focusing on the `@passway/api` component. Adhering to these guidelines ensures the codebase remains consistent, readable, and maintainable.

## 1. File and Directory Structure

The API project (`server/api`) follows a feature-first or domain-driven structure.

- **Group by Feature/Domain:** Code related to a specific feature or domain (e.g., `user`, `session`) should be grouped together.
- **Routes:** All API routes are located in `src/routes/`. Versioning is handled by a directory structure (e.g., `src/routes/v1/`). Each domain within a version has its own subdirectory (e.g., `src/routes/v1/user/`) containing an `index.ts` for the Fastify plugin and an `index.test.ts` for its tests.
- **Services:** Complex business logic that is reused across multiple routes or is too complex for a route handler should be abstracted into a service class in the `src/services/` directory. Each service should have its own subdirectory (e.g., `src/services/Upload/`).
- **Prisma Schema:** The database schema is defined exclusively in `prisma/schema.prisma`.
- **Hooks:** Reusable Fastify hooks (e.g., for authentication) are placed in `src/hooks/`.

## 2. TypeScript Usage

We leverage TypeScript's static typing to build a robust and error-free application.

- **Strict Mode:** The project is configured with `"strict": true` in `tsconfig.json`.
- **Domain-Specific Types:** For API requests and replies, define specific interfaces (e.g., `UserGetApi` in the user route). This provides type safety and clarity for what data is expected and returned.
- **Prisma Types:** Utilize the types automatically generated by Prisma for database models (e.g., `User`, `Prisma.UserUpsertArgs`). Avoid redefining these types.
- **`async/await`:** All asynchronous operations must use `async/await`. Avoid using raw Promises or `.then()` chains for flow control.

## 3. Fastify Patterns

- **Plugins for Encapsulation:** All route groups and core functionalities (like the Prisma client) are implemented as Fastify plugins. This keeps concerns separated and the main application file (`src/app.ts`) clean.
- **Schema is King:** Every route **must** have a schema defined for its `body`, `querystring`, `params`, `headers`, and `response`. This is critical for validation, serialization, and automatic Swagger documentation. Use TypeBox to define these schemas for full type-safety.
- **Route Handlers:** Keep route handlers as lean as possible. Their primary responsibility is to:
  1.  Parse the request.
  2.  Call services or perform database queries.
  3.  Format the response.
      **Complex business logic should be delegated to services.**
- **Dependency Injection:** Use Fastify's `decorate` API to inject shared dependencies (like `prisma` or `minioClient`) into the application instance. Avoid global singletons.

## 4. API Design

- **Versioning:** The API is versioned via the URL prefix (e.g., `/api/v1/...`).
- **RESTful Principles:** Strive to follow RESTful principles for naming and HTTP methods (e.g., `GET` for retrieval, `PUT` for create/update, `DELETE` for removal).
- **Status Codes:** Use appropriate HTTP status codes from the `http-status-codes` library. For example:
  - `200 OK`: Successful `GET` or `PUT` (update).
  - `201 CREATED`: Successful `PUT` (creation).
  - `400 BAD REQUEST`: Client-side validation error.
  - `401 UNAUTHORIZED`: Missing or invalid authentication.
  - `403 FORBIDDEN`: Authenticated user does not have permission.
  - `404 NOT FOUND`: Resource not found.
  - `500 INTERNAL SERVER ERROR`: Unexpected server error.

## 5. Error Handling

- **Use `http-errors`:** For all expected error conditions that should be reported to the client (e.g., not found, permission denied), use the `http-errors` library to generate a standardized error object.
- **Log Unexpected Errors:** In `catch` blocks, always log the full error for debugging purposes (`app.log.error(e)`). Return a generic `500 Internal Server Error` to the client to avoid leaking implementation details.
- **Be Specific in Logs:** When logging informational messages (`app.log.info`), provide context. For example, instead of "User updated", log "User `123` updated successfully".

## 6. Testing

- **Co-location of Tests:** Write tests in an `index.test.ts` file within the same directory as the code being tested.
- **Unit vs. Integration:**
  - **Unit Tests:** Test individual functions or classes in isolation. Use mocking (`vitest-mock-extended`) to isolate dependencies.
  - **Integration Tests:** Test that multiple components work together correctly. The project has a separate `vitest.config-integration.js` for this purpose. Integration tests use real, local, ephemeral application infrastructure via Docker.
- **Test Coverage:** Aim for high test coverage, especially for critical business logic and error paths. Use `vitest` with the `--coverage` flag to check this.
- **Descriptive Test Names:** Test names should clearly describe what they are testing in a "given-when-then" or "should do X when Y" format.
